"use client"

import { account, databases } from "@/lib/appwrite.config";
import * as sdk from "node-appwrite";
import { Query } from "appwrite";
import { toast } from "sonner";
import { useRouter } from "next/navigation";

const DATABASE_ID = '6720cc9c000049efcd3c';
const PATIENT_COLLECTION_ID = '6720ccbd0028468dee7e';
const APPOINTMENT_COLLECTION_ID = '6720d51d0006e3cf342e';

export async function loginUser({
  email,
  password,
}: {
  email: string;
  password: string;
}) {
  try {
    // Use Appwrite's createEmailSession API
    const session = await account.createEmailPasswordSession(
      email,
      password
    );

    // Return the session object for successful login
    return { success: true, session };
  } catch (error: any) {
    console.error("Login error:", error);
    throw new Error(error.message || "Login failed. Please try again.");
  }
}


// Function to register a user
export async function registerUser({
  email,
  password,
  fullName,
  age,
  dateOfBirth,
  contactNo,
  sex,
  items,
}: {
  email: string;
  password: string;
  fullName: string;
  age: number;
  dateOfBirth: string;
  contactNo: string;
  sex: string;
  items: string[];
}) {
  try {
    // Create user in Appwrite authentication system
    const user = await account.create(
      "unique()", // unique ID generated by Appwrite
      email,
      password,
      fullName
    );

    // Create document in Appwrite database with additional user information
    await databases.createDocument(
      DATABASE_ID,
      PATIENT_COLLECTION_ID,
      "unique()",
      {
        fullName,
        email,
        age,
        birthday: dateOfBirth,
        number: contactNo, // No conversion needed; it's already a string
        medicalConcerns: items,
        sex,
        password,
      },
      [
        sdk.Permission.read("users"),
        sdk.Permission.update("users"),
      ]
    );    

    return { success: true, user };
  } catch (error) {
    console.error("Registration error:", error);
    throw new Error("Registration failed. Please try again.");
  }
}

type appointmentStatus = "pending" | "approved" | "declined";

// Function to make an appointment
export async function makeAppointment({
  lab,
  packages,
  consultation,
  reason,
  note,
  dateTime,
  userId,
  status,
  fullName,
}: {
  lab: string[];
  packages: string[];
  consultation: string[];
  reason: string;
  note: string;
  dateTime: string;
  userId: string;
  status: appointmentStatus;
  fullName: string;
}) {
  try {
    const appointment = await databases.createDocument(
      DATABASE_ID,
      APPOINTMENT_COLLECTION_ID,
      "unique()",
      {
        lab,
        packages,
        consultation,
        reason,
        note,
        dateTime,
        userId,
        status,
        fullName,
      },
      [
        sdk.Permission.read("users"),
        sdk.Permission.update("users"),
      ]
    );
    console.log(appointment.userId);
    return appointment;
  } catch (error) {
    console.error("Error creating appointment:", error);
    throw error;
  }
}

export async function getUserAppointments(userId: string) {
  try {
    const appointments = await databases.listDocuments(
      DATABASE_ID,
      APPOINTMENT_COLLECTION_ID,
      [
        Query.contains("userId", userId),
        Query.select(["status", "dateTime", "lab", "packages", "consultation"]),
      ] 
  );
    return appointments.documents;
  } catch (error) {
    console.error("Error fetching appointments:", error);
    throw error;
  }
}


export async function getUserInfo() {
  try {
    const user = await account.get();
    const userEmail = user.email;

    const userDocuments = await databases.listDocuments(
      DATABASE_ID!,
      PATIENT_COLLECTION_ID!,
      [Query.equal("email", userEmail)]
    );

    if (userDocuments.documents.length === 0) {
      throw new Error("User not found in the Patient collection.");
    }

    return userDocuments.documents[0];
  } catch (error) {
    console.error("Error fetching user info:", error);
    throw error;
  }
}

export async function userLogout() {
  try {
    await account.deleteSession("current");
    toast.success("Logout successful!");
    const router = useRouter();
    router.push("/src/login");
    return { success: true };
  } catch (error) {
    const router = useRouter();
    router.push("/src/login");
    // toast.error("Logout failed. Please try again.");
    // throw error; // Rethrow the error
  }
}