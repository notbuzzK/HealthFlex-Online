"use client"

import { account, databases, storage } from "@/lib/appwrite.config";
import * as sdk from "node-appwrite";
import { Query } from "appwrite";
import { toast } from "sonner";
import { useRouter } from "next/navigation";

const DATABASE_ID = '6720cc9c000049efcd3c';
const PATIENT_COLLECTION_ID = '6720ccbd0028468dee7e';
const APPOINTMENT_COLLECTION_ID = '6720d51d0006e3cf342e';
const FILES_COLLECTION_ID = '6762e8190003407359d5';
const BUCKET_ID = '6720dbd4000ebb15270b';

export async function loginUser({
  email,
  password,
}: {
  email: string;
  password: string;
}) {
  try {
    // Use Appwrite's createEmailSession API
    const session = await account.createEmailPasswordSession(
      email,
      password
    );

    // Return the session object for successful login
    return { success: true, session };
  } catch (error: any) {
    console.error("Login error:", error);
    throw new Error(error.message || "Login failed. Please try again.");
  }
}


// Function to register a user
export async function registerUser({
  email,
  password,
  fullName,
  age,
  dateOfBirth,
  contactNo,
  sex,
  items,
}: {
  email: string;
  password: string;
  fullName: string;
  age: number;
  dateOfBirth: string;
  contactNo: string;
  sex: string;
  items: string[];
}) {
  try {
    // Create user in Appwrite authentication system
    const user = await account.create(
      "unique()", // unique ID generated by Appwrite
      email,
      password,
      fullName
    );

    // Create document in Appwrite database with additional user information
    await databases.createDocument(
      DATABASE_ID,
      PATIENT_COLLECTION_ID,
      "unique()",
      {
        fullName,
        email,
        age,
        birthday: dateOfBirth,
        number: contactNo, // No conversion needed; it's already a string
        medicalConcerns: items,
        sex,
        password,
      },
      [
        sdk.Permission.read("users"),
        sdk.Permission.update("users"),
      ]
    );    

    return { success: true, user };
  } catch (error) {
    console.error("Registration error:", error);
    throw new Error("Registration failed. Please try again.");
  }
}

type appointmentStatus = "pending" | "approved" | "declined";

// Function to make an appointment
export async function makeAppointment({
  lab,
  packages,
  consultation,
  note,
  dateTime,
  userId,
  status,
  fullName,
}: {
  lab: string[];
  packages: string[];
  consultation: string[];
  note: string;
  dateTime: string;
  userId: string;
  status: appointmentStatus;
  fullName: string;
}) {
  try {
    const appointment = await databases.createDocument(
      DATABASE_ID,
      APPOINTMENT_COLLECTION_ID,
      "unique()",
      {
        lab,
        packages,
        consultation,
        note,
        dateTime,
        userId,
        status,
        fullName,
      },
      [
        sdk.Permission.read("users"),
        sdk.Permission.update("users"),
      ]
    );
    console.log(appointment.userId);
    return appointment;
  } catch (error) {
    console.error("Error creating appointment:", error);
    throw error;
  }
}

export async function getUserAppointments(userId: string) {
  try {
    const appointments = await databases.listDocuments(
      DATABASE_ID,
      APPOINTMENT_COLLECTION_ID,
      [
        Query.contains("userId", userId),
        Query.select(["status", "dateTime", "lab", "packages", "consultation", "reason",]),
        Query.orderDesc('$createdAt'),
      ] 
  );
    return appointments.documents;
  } catch (error) {
    console.error("Error fetching appointments:", error);
    throw error;
  }
}


export async function getUserInfo() {
  try {
    const user = await account.get();
    const userEmail = user.email;

    const userDocuments = await databases.listDocuments(
      DATABASE_ID!,
      PATIENT_COLLECTION_ID!,
      [Query.equal("email", userEmail)]
    );

    if (userDocuments.documents.length === 0) {
      throw new Error("User not found in the Patient collection.");
    }

    return userDocuments.documents[0];
  } catch (error) {
    console.error("Error fetching user info:", error);
    throw error;
  }
}

export async function userLogout(router: ReturnType<typeof useRouter>) {
  try {
    await account.deleteSession("current");
    toast.success("Logout successful!");
    router.push("/src/login");
    return { success: true };
  } catch (error) {
    console.error("Error logging out:", error);
    toast.error("Failed to log out. Redirecting to login page.");
    router.push("/src/login");
  }
}


export async function updateUserDocument(email: string, data: any) {
  try {
    const documentId = await databases.listDocuments(
      DATABASE_ID,
      PATIENT_COLLECTION_ID,
      [
        Query.equal("email", [email]),
      ]
    );

    await databases.updateDocument(
      DATABASE_ID,
      PATIENT_COLLECTION_ID,
      documentId.documents[0].$id, 
      data, 
    )

    if (data.password && data.password !== "") {
      await account.updatePassword(data.password, data.currentPassword);
    }

    if (data.fullName && data.fullName !== "") {
      await account.updateName(data.fullName);
    }

  } catch (error) {
    console.error("Error updating user document:", error);
    throw error;
  }
}

export async function uploadFile(fullName, file) {
  const uploadedFile = await storage.createFile(
    BUCKET_ID,
    "unique()",
    file
  );

  const fileId = uploadedFile.$id;

  // get user document from collection
  const existingUserDoc = await databases.listDocuments(
    DATABASE_ID,
    FILES_COLLECTION_ID,
    [Query.equal("fullName", fullName)]
  );

  if (existingUserDoc.total > 0) {
    // append fileIds if user document exists
    const userDoc = existingUserDoc.documents[0];
    const updatedFiles = [...userDoc.fileId, fileId];

    await databases.updateDocument(
      DATABASE_ID,
      FILES_COLLECTION_ID,
      userDoc.$id,
      {
        fileId: updatedFiles,
      }
    );
  } else {
    // if no document exists, create a new one
    await databases.createDocument(
      DATABASE_ID,
      FILES_COLLECTION_ID,
      "unique()",
      {
        fullName,
        fileId: [fileId], 
      }
    );
  }

  return fileId;
}
